# 笔记

> <https://github.com/wangzheng0822/algo>

## 书籍

![t2](./algorithm/algorithm_books.jpg)

## 03 复杂度分析

### 复杂度量级

- 常量阶 O(1)
- 对数阶 O(logn)
- 线性阶 O(n)
- 线性对数阶 O(nlogn)
- 平方阶 O(n2)
- 立方阶 O(n3)
- 指数阶 O(2^n)
- 阶乘阶 O(n!)

- 均摊时间复杂度一般等于最好情况时间复杂度

## 05 数组

- 线性表
- 数组适合查找(下标查找, 而不是普通查找)
  - 支持随机访问(地址连续), 根据下标访问O(1)
  - 排序好的查找操作O(logn)
- 插入、删除操作平均O(n)

### 字节序

- 大端模式: 人类阅读模式, 高位高字节
- 小端模式: 利于某些计算机处理场合, 地位高字节

![t0501](./algorithm/byte-order.jpg)

    # 0x1234()
    # 0x101 0x102
      12    34      # 大端模式
      34    12      # 小端模式

## 06 链表

- 时间复杂度
  - 查找O(n)
  - 插入/删除O(1)
- 循环链表
  - 约瑟夫问题
- 双向链表deque(double-end-queue)
  - 在指定节点前插入, 比单链表优势O(1)
  - 空间换时间(例子: 缓存)

## 07 链表练习

- 使用哨兵(头指针)简化判断
- 留意边界条件处理
  - 链表为空
  - 只包含一个节点
  - 只包含2个节点
  - 处理头尾节点
- 画图辅助

- 单链表反转(206)
- 链表环检测(141)
- 两个有序链表合并(21)
- 删除链表倒数第n节点(19)
- 求链表中间节点(876)

## 08 栈

## 09 队列

- 线程安全的队列叫做`并发队列`, 利用CAS原子操作, 可以实现高效并发队列(无锁队列)
- CAS, 在入队前，获取tail位置，入队时比较tail是否发生变化，如果否，则允许入队，反之，本次入队失败。出队则是获取head位置，进行cas。

## 10 递归

- 是否可以递归
  - 问题的解可以分解为几个子问题的解。何为子问题？就是数据规模更小的问题
  - 问题与子问题，除了数据规模不同，求解思路完全一样
  - 存在递归终止条件
- 编写关键
  - 找到将大问题分解为小问题的规律
  - 写出递推公式, 假设子问题已经解决, 不深入
  - 推敲终止条件
  - 翻译代码
- 注意重复计算

## 12 排序(归并, 快排)

- 分治思想, 递归实现
- 归并
  - 稳定
  - 非原地算法(不占额外空间)
  - 时间复杂度O(nlogn)
- 快排
  - 不稳定
  - 原地排序算法
    - 分区函数
  - 时间复杂度O(nlogn), 最差(已排序)O(n**2)

## 13 线性排序

- 由于均为O(n), 所以叫线性排序
- 非基于比较的算法, 不涉及元素之间比较操作
- 桶排序(Bucket Sort)
  - O(nlog(n/m)): m个桶内部快排, 当桶个数趋近排序数据个数, 接近O(n)
  - 桶间有天然大小关系
  - 适合外部排序(数据在外部磁盘中, 数据量大, 内存小)
  - 如果单个桶数据量任然很大, 递归桶排序
- 计数排序(Counting Sort)
  - 桶排序特殊情况(桶内区间为1, 省掉内部排序时间)
  - 如高考排名, 751个桶
  - 原理
    - 先桶排序得出每个桶内个数, 该数组为C[]
    - 再顺序求和, 每个桶内为前n项和, 数组B[c+]
    - 从原始序列A[]末尾(n-1)依次插入(倒序保证稳定)
    - 由 A[n-1]=a 的值找到B[a]对应的值, 插入最终数组D[b]
    - 累加数组该位置值减一, 指向前一D[]可插入位置, B[a] += 1
  - 要求
    - 适用于数据范围不大的场景
    - 只能非负整数, 如果为其他值需要转换, 负数加, 小数乘
- 基数排序(Radix Sort)
  - 要求
    - 数据需要可以分割出独立的位比较, 位间有递进关系, 如手机号排序
    - 每位数据范围不能太大, 因为要用线性排序算法
    - 线性排序必须稳定(下层需要使用归并排序)
    - 数据可以对齐(相同长度), 否则需要补齐位数
  - 复杂度, O(k*n), k位, 每位用线性排序, k有限, 则最终为O(n)

## 14 通用高性能排序函数

              时间复杂度        稳定    原地
    冒泡        O(n**2)         O       O
    插入        O(n**2)         O       O
    选择        O(n**2)         X       O
    快速        O(nlogn)        X       O
    归并        O(nlogn)        O       X
    计数        O(n+k)          O       X
    桶          O(n)            O       X
    基数        O(dn)d是维度     O       X

## 15 二分查找1

- 有序集合
- 速度O(logn)
- 实现
  - 注意循环退出条件, low<=high
  - mid取值直接写`m=(l+h)/2`, 当low和high比较大, 和可能会溢出
    - 改进1, `l+(h-l)/2`
    - 改进2, `l+((h-l)>>1), 位运算比除法更高效
  - low和high的更新, 新high=mid-1, 新low=mid+1, 如果low=mid, 会导致死循环([3,3]区间, 上下限一直是33)
- 局限
  - 必须数组, 依赖顺序表结构
  - 需要有序
  - 太大不合适(需要连续的地址空间)
- 适用于近似查找问题(第一个小于等于, 最后一个大于这类)

## 16 二分查找2

> [完全总结和分析](https://github.com/yuzhoujr/leetcode/issues/8)

查找第一个等于给定值的元素

- 步骤
  - low, high初始化
  - 循环
    - mid初始化
    - if >
    - elif <
    - 是否=0(左边界) or mid-1 !=
      - 是 ok
      - 否 右侧左移
  - 没找到 -1

``` py
# 第一个等于给定值的元素n
def first_one(a: List[int], n):
    low = 0
    high = len(a) - 1
    while low <= high:
        mid = low + ((high-low) >> 1)
        if a[mid] < n:
            low = mid + 1
        elif a[mid] > n:
            high = mid - 1
        else:
            if mid == 0 or a[mid-1] < n:
                return mid
            else:
                high = mid - 1
    return -1
```

## 17 跳表

- 有序序列建立多级索引
- 插入/删除/查找均为O(logn)

## 18 散列表1(Hash Table)

- 是数组的一种扩展
- 通过键(key)经过散列函数计算得出散列值
- 解决散列冲突
  - 开放寻址法(open addressing), 重新探测一个空闲空间
    - 线性探测(Linear Probing), 依次向后查找, 删除时插入`delete`标识, 否则破坏查询规则
    - 二次探测(Quadratic probing), 类似线性探测, 但步长变为每次n**2
    - 双重散列(Double hashing), 用两个hash函数, 第一个冲突使用第二个, 以此类推
    - 装载因子(load factor), = 填入元素/总长度, 因子越大, 空闲位置越少, 散列表性能下降
  - 链表法(chaining), hash值为散列槽位, 将元素插入较为对应的链表中, 理想时间复杂度O(n/m), n总数, m槽位数

## 19 散列表2, 工业级设计

- 设计散列函数
  - 散列函数设计不能复杂, 否则消耗性能
  - 散列函数生成值要尽可能随机且均匀分布
- 避免装载因子过大
  - 动态扩容, 需要重新计算所有散列值
- 避免低效扩容
  - 扩容时, 新值插入新表, 同时迁移一个, 直到老表所有搬完
  - 查找时, 先查新表, 再查老表
- 冲突解决方法
  - 开放寻址法
    - 优点
      - 数组存储, 可以利于CPU缓存加快速度
      - 序列化简单
    - 缺点
      - 删除数据麻烦
      - 冲突代价更高
      - 为了减少冲突, 装载因子不能太大, 所以需要更大内容
    - 适用, 数据量较小, 装载因子小
  - 链表法
    - 优点
      - 内存利用率高
      - 对装载因子容忍度更高, 甚至可以到10
    - 缺点
      - 存储小对象时可能内存消耗翻倍
      - 对CPU缓存不友好
    - 优化
      - 将链表改为跳表或者红黑树, 这样即使冲突, 极端情况下也是退化为O(logn)
    - 适用, 适合大对象, 大数据量, 更灵活, 支持更多优化策略

### 工业级散列表

- 要求
  - 支持快速增删查
  - 内存合理
  - 性能稳定, 极端情况也不能退化到无法接受
- 实现
  - 设计合适散列函数
  - 定义装载因子阈值, 设计动态扩容策略
  - 选择合适的散列冲突解决方法

## 20 散列表3, 散列表和链表经常一起使用

散列表可以高效维护数据, 但是无法按照某种顺序快速遍历, 所以需要借助链表

## 21-22 哈希算法

- 算法要求
  - 不能反向推导出原始数据, 所以也叫单向哈希算法
  - 对输入数据敏感, 即使修改1bit, 得到的hash值也不同
  - 散列冲突概率要小, 不同数据, 相同hash概率需要很小
  - 执行效率要尽量高, 针对长文本, 也能快速计算
- 应用
  - 安全加密(保护密码等), 但是无法做到0冲突(鸽巢原理)
  - 唯一标识, 摘要算法, 唯一标识图片等
  - 数据校验, BT下载大文件
  - 散列函数
  - 负载均衡, 同一客户端在一次会话的所有请求都路由到同一台服务器(会话粘滞(session sticky)), ip hash后取模(服务器数量)
  - 数据分片, 数据分片后根据内容分配到该内容对应的机器, 实现多数据片相同内容分配到同一台机器, 实现分布式
  - 分布式存储
    - 雪崩效应, hash后取模基于服务器数量n, n变动后, 所有hash都要重新计算(即缓存失效), 导致所有请求都会发往后端, 引起雪崩
    - 一致性哈希算法, 解决上述问题, 引入环
      - 虚拟环, 等分2**32, 服务器id hash后散落在环上, 数据hash在环上后, 顺时针落在对应服务器
      - 虚拟节点, 服务器在少量时在环上位置不均匀, 引入虚拟节点, 即每个服务器(A)代表若干虚拟节点(A1-A3), 对虚拟节点hash, 这样逻辑上增加数量

## 23 二叉树1

                                高度    深度     层
                   O            2       0       1
                 /   \
                O     O         1       1       2
               / \   / \
              O   O O   O       0       2       3

- 节点高度: 节点到叶子节点的最长路径(边数), 从下向上, 起点地面
- 节点深度: 根节点到这个节点所经历的边的个数, 从上到下, 起点0点
- 节点层数: 深度+1
- 树的高度: 根节点的高度

- 二叉树
  - 满二叉树, 叶子节点全部在最底层, 除叶子节点外, 每个节点都有左右子节点
  - 完全二叉树, 叶子节点都在最底下两层, 最后一层的叶子节点都靠左排列, 除了最后一次, 其他层节点个数都要达到最大
- 存储
  - 链式存储法, 链表
  - 顺序存储法, 数组
- 遍历
  - 前中后序遍历
  - 复杂度O(n)
- 二叉查找树
  - 树中任一节点, 大于其左子树的每个节点值, 小于右子树每个节点
  - 中序遍历得出升序序列

## 28 堆(Heap)和堆排序

- 堆是一种特殊的树
  - 完全二叉树
  - 每个节点大于等于(或小于等于)子树的每个节点(左右子节点, 等价)
- 种类
  - 大顶堆, 顶点最大
  - 小顶堆, 顶点最小
- 操作(实现)
  - 堆化(heapify)
    - 从下往上
